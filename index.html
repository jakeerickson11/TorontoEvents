<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>City Events Map</title>
 
  
  <style>
/* ----- (same styles as your file, unchanged) ----- */
:root{
  --bg:#dde0e2;        /* off-black page background */
  --card:#ffffff;      /* white panels for contrast */
  --muted:#7a8aa0;
  --text:#e6eef7;
  --cat-active:#16a34a;
  --cat-creative:#a855f7;
  --cat-entertain:#eab308;
  --cat-competitive:#f97316;
  --cat-relax:#3b82f6;
}
*{box-sizing:border-box}
body{margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu; background:var(--bg); color:var(--text)}
/* Dark header with bright text */
header{
  padding:16px 20px;
  border-bottom:1px solid #364152; /* subtle divider */
  position:sticky; top:0;
  background:#0b0f14;            /* dark */
  color:#f8fafc;                  /* bright text */
  z-index:5;
}
header h1{ margin:0; font-size:20px; color:#f8fafc; }
header a{ color:#f8fafc; }        /* any header links/buttons */

.container{display:grid; grid-template-columns: 1.2fr 1fr; gap:16px; padding:16px}
#map{height: calc(100vh - 100px); border-radius:16px; overflow:hidden; border:1px solid #e5eaf1}
.panel{background:var(--card); border:1px solid #e5eaf1; border-radius:16px; overflow:hidden; display:flex; flex-direction:column}
.filters{padding:12px; border-bottom:1px solid #e5eaf1; display:grid; grid-template-columns: 1fr; gap:12px}
.filters .row{display:flex; gap:12px; flex-wrap:wrap; align-items:center}
.filters label{font-size:12px; color:var(--muted)}
.filters input{padding:8px 10px; border-radius:10px; border:1px solid #d0d7e2; background:#ffffff; color:var(--text)}
.filters .cats{display:flex; gap:8px; flex-wrap:wrap}
.chip{display:flex; gap:6px; align-items:center; font-size:12px; border:1px solid #d0d7e2; padding:6px 8px; border-radius:999px; background:#f8fafc; color:var(--text); cursor:pointer}
.dot{width:10px; height:10px; border-radius:999px; display:inline-block}
.cal{border:1px solid #e5eaf1; border-radius:12px; padding:8px; background:#ffffff; min-height:260px}
.cal-header{display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:6px}
.cal-nav{display:flex; gap:6px}
.cal-btn{padding:6px 10px; border:1px solid #d0d7e2; background:#ffffff; color:var(--text); border-radius:10px; cursor:pointer}
.cal-btn:disabled{opacity:.45; cursor:not-allowed}
.cal-title{font-size:12px; color:var(--muted)}
.cal-grid{display:grid; grid-template-columns: repeat(7, 1fr); gap:4px}
.cal-wd{font-size:11px; color:#6b7280; text-align:center; padding:4px 0}
.cal-day{font-size:12px; text-align:center; padding:8px 0; border-radius:10px; border:1px solid #d0d7e2; background:#ffffff; cursor:pointer; user-select:none}
.cal-day:hover{border-color:#94a3b8}
.cal-day.out{opacity:.35; cursor:default}
.cal-day.disabled{opacity:.45; pointer-events:none}
.cal-day.selected{outline:2px solid var(--accent); outline-offset:1px}
.cal-day.hasEvents{background:#eef2ff}
.cal-legend{font-size:11px; color:#6b7280; margin-top:6px}
.list{overflow:auto; background:#ffffff}
.item{display:grid; grid-template-columns: 72px 1fr; gap:12px; padding:12px; border-bottom:1px solid #e5eaf1; cursor:pointer; background:#ffffff}
.item:hover{background:#f5f7fb}
.thumb{width:72px; height:72px; border-radius:12px; object-fit:cover; border:1px solid #e5eaf1}
.meta{display:flex; flex-direction:column; gap:4px}
.title{font-weight:600}
.sub{color:var(--muted); font-size:12px}
.badge{display:inline-flex; align-items:center; gap:6px; font-size:11px; padding:4px 8px; border-radius:999px; border:1px solid #d0d7e2; background:#ffffff}
.leftStripe{width:6px; border-radius:0 6px 6px 0}
.footer{padding:10px; font-size:12px; color:var(--muted)}
@media (max-width: 960px){
  .container{grid-template-columns:1fr;}
  /* Fallback first, then better viewport units if supported */
  #map{
    height:42vh;   /* fallback */
    height:42svh;  /* small-viewport height */
    height:42dvh;  /* dynamic viewport height (best) */
  }
}

/* Make it even shorter on very small phones */
@media (max-width: 600px){
  #map{
    height:36vh;
    height:36svh;
    height:36dvh;
  }
}
@media (max-width: 420px){
  #map{
    height:32vh;
    height:32svh;
    height:32dvh;
  }
}


    
/* Make the right panel + controls readable on white */

.list,
.filters,
.badge,
.chip { background:#ffffff; color:#0f172a; border-color:#e5eaf1; }

.panel {
  /* keep your existing panel styles */
  height: calc(100vh - 100px); /* same as .map so they line up */
}

.list {
  flex: 1;
  min-height: 0;     /* new */
  overflow: auto;    /* you already had this — leave it in */
}

    
.filters input {
  background:#ffffff; color:#0f172a; border:1px solid #d0d7e2;
}

.meta .sub,
.filters label { color:#475569; }

.item { background:#ffffff; }
.item:hover { background:#f5f7fb; }
.thumb { border-color:#e5eaf1; }

/* Keep the header subtle on off-black; optional: */
/* header { background: linear-gradient(180deg, rgba(14,17,20,0.95), rgba(14,17,20,0.85)); } */

/* Pinned event bar (shows under header on phones) */
.pinned{ margin:8px 16px 0 16px; }
.pinned.hidden{ display:none; }
.pinnedCard{
  display:grid; grid-template-columns:64px 1fr; gap:12px; align-items:center;
  background:var(--card); color:var(--text);
  border:1px solid #e5eaf1; border-radius:12px; padding:10px;
}
.pinnedCard .thumb{
  width:64px; height:64px; border-radius:10px; object-fit:cover; border:1px solid #e5eaf1;
}
.pinnedTitle{ font-weight:600; }
.pinnedMeta{ font-size:12px; color:var(--muted); }
.pinnedBadge{
  display:inline-flex; align-items:center; gap:6px; font-size:11px;
  padding:4px 8px; border-radius:999px; border:1px solid #d0d7e2; background:#ffffff;
}
.pinned .dot{ width:10px; height:10px; border-radius:999px; display:inline-block; }

/* Hide the pinned bar on desktop/tablet; only show on phones */
@media (min-width: 961px){
  .pinned{ display:none; }
}

/* Clear (×) button on pinned card */
.pinnedCard { position: relative; }
.pinnedClear{
  position:absolute; top:6px; right:6px;
  display:inline-flex; align-items:center; justify-content:center;
  width:28px; height:28px; border-radius:8px;
  border:1px solid #d0d7e2; background:#ffffff; color:#475569;
  cursor:pointer; line-height:1; font-size:16px;
}
.pinnedClear:hover{ background:#f5f7fb; }
.pinnedClear:focus{ outline:2px solid var(--accent); outline-offset:2px; }


/* Slimmer list items on phones */
@media (max-width: 960px){
  .item{
    /* text left (1fr) + small image right (auto) */
    grid-template-columns: 1fr 56px;
    gap: 8px;
    padding: 8px 10px;
  }
  .item .leftStripe{ display:none; }        /* hide the side stripe to save space */
  .thumb{ width:56px; height:56px; }        /* smaller image */
  .meta{ gap: 2px; }                        /* tighter spacing between lines */
  .title{ font-size:14px; line-height:1.2; }
  .sub{ font-size:11px; line-height:1.2; }
  .badge{ display:none; }                   /* optional: hide category pill to reduce height */
}
/* Title row with inline badge on phones */
@media (max-width: 960px){
  .titleRow{
    display:flex; align-items:center; gap:6px;
    min-width:0; /* lets ellipsis work */
  }
  .title{
    font-size:14px; line-height:1.2;
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    flex:1 1 auto; /* title can shrink */
  }
  .badge{
    display:inline-flex; align-items:center; gap:6px;
    font-size:10px; padding:2px 6px; border-radius:999px;
    border:1px solid #d0d7e2; background:#ffffff;
    white-space:nowrap; flex:0 0 auto; /* badge stays compact */
  }
  .badge .dot{ width:8px; height:8px; }
}

/* No horizontal scroll in the events list */
#eventsList { overflow-x: hidden; }

/* Mobile text wrapping & clamping */
@media (max-width: 960px){
  /* Let grid children shrink on small screens */
  .item > * { min-width: 0; }
  .meta     { min-width: 0; }

  /* Title on one line with badge… OR clamp to 2 lines (pick ONE style below) */

  /* A) Clamp title to 2 lines with ellipsis (recommended: fixed height, tidy) */
  .title{
    white-space: normal;              /* override any nowrap */
    display: -webkit-box;
    -webkit-line-clamp: 2;            /* show up to 2 lines */
    -webkit-box-orient: vertical;
    overflow: hidden;
    line-height: 1.2;
    font-size: 14px;
    overflow-wrap: anywhere;          /* break very long words if needed */
    word-break: break-word;
    hyphens: auto;
  }

  /* Sub-lines (venue, date/time, link) kept to 1 line with ellipsis */
  .sub{
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  /* Make sure the row itself can't create horizontal scroll */
  .item{
    overflow: hidden;     /* hide any accidental overflow */
  }
}
/* Make pinned event title dark on the white card */
.pinnedCard .pinnedTitle {
  color: #0f172a !important; /* deep near-black */
}

    /* Pinned card: make the category pill text dark */
.pinnedCard .pinnedBadge {
  color: #0f172a !important;   /* deep near-black text */
  background: #ffffff;         /* keep white pill */
  border-color: #d0d7e2;       /* subtle border */
}

/* ===== Fast sliding header (fixed) ===== */
:root{ --header-h: 64px; }              /* JS will set real height */

/* Make header fixed so content never scrolls over it */
header{
  position: fixed; top: 0; left: 0; right: 0;
  z-index: 1000;
  transition: transform .12s ease;      /* faster animation */
  will-change: transform;
}

/* Spacer reserves header height to avoid layout jump */
#headerSpacer{
  height: var(--header-h);
  transition: height .12s ease;
}

/* Hide header & collapse spacer */
.header-hidden header{ transform: translateY(-100%); }
.header-hidden #headerSpacer{ height: 0; }

/* ===== Stack order hardening: keep header on top of map layers ===== */

/* Make header the top-most thing */
header{
  position: fixed;        /* you already have this from the slide-up setup */
  top: 0; left: 0; right: 0;
  z-index: 9999;          /* higher than any Leaflet pane/control */
  will-change: transform;
  backface-visibility: hidden; /* reduces flicker on iOS during fast scroll */
}

/* Keep the spacer + pinned card above the map but below the header */
#headerSpacer,
#pinnedEvent{
  position: relative;
  z-index: 9998;
}

/* Ensure the map never competes with the header 
#map, .leaflet-container{ position: relative; z-index: 1; } */

/* Lower Leaflet UI layers so they can't pop over the header during momentum scroll 
.leaflet-top,
.leaflet-bottom{ z-index: 1000 !important; }   /* zoom controls, attribution 
.leaflet-popup-pane,
.leaflet-tooltip-pane,
.leaflet-marker-pane{ z-index: 900 !important; } /* popups, tooltips, markers */


/* Desktop: stripe | text | image */
@media (min-width: 961px){
  .item{
    display: grid;
    grid-template-columns: 6px 1fr 64px;  /* stripe | text | image */
    gap: 10px;
    padding: 10px 12px;
    align-items: center;
  }
  .leftStripe{
    grid-column: 1;
    grid-row: 1 / -1;       /* run full height of the row */
    display: block;         /* make sure it’s visible */
  }
  .meta{
    grid-column: 2;         /* text on the left side */
    min-width: 0;           /* allow ellipsis/wrap */
    gap: 4px;
  }
  .thumb{
    grid-column: 3;         /* image on the right side */
    width: 64px;
    height: 64px;
    justify-self: end;
  }

  /* Make items thinner vertically */
  .title{
    white-space: normal;
    display: -webkit-box;
    -webkit-line-clamp: 2;      /* up to 2 lines */
    -webkit-box-orient: vertical;
    overflow: hidden;
    line-height: 1.2;
    font-size: 15px;
  }
  .sub{
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
}

/* Locate (current position) button */
/*.leaflet-bar.locate-btn{
  background:#fff; border:1px solid #e5eaf1; border-radius:4px;
  box-shadow: 0 1px 3px rgba(0,0,0,.08);
}
.leaflet-bar.locate-btn button{
  display:block; width:32px; height:32px; line-height:32px; text-align:center;
  background:#fff; border:0; cursor:pointer; font-size:18px;
}
.leaflet-bar.locate-btn button:hover{ background:#f5f7fb; } */

/* Directions button */
.dirBtn{
  display:inline-flex; align-items:center; gap:6px;
  font-size:12px; padding:6px 10px; border-radius:10px;
  border:1px solid #d0d7e2; background:#ffffff; color:#0f172a;
  text-decoration:none; cursor:pointer;
}
.dirBtn:hover{ background:#f5f7fb; }

/* Pinned card: actions row (for Directions button) */
.pinnedActions{
  display:flex; gap:8px; flex-wrap:wrap; margin-top:6px;
}

/* Selected list item highlight */
.item.selected{
  background: #eef2ff;                 /* subtle highlight */
  border-color: var(--accent);         /* optional, if your .item has a border */
}

.item { cursor: pointer; }
.item.selected { background:#eef2ff; border-color: var(--accent); }

/* Header layout with inline date picker */
header{
  display:flex; align-items:flex-start; justify-content:space-between;
  gap:12px; flex-wrap:wrap; z-index:9999; /* stays above map */
}
.headerControls{ display:flex; align-items:center; gap:10px; }

header .headerControls input[type="date"]{
  padding:8px 10px; border:1px solid #d0d7e2; border-radius:10px;
  background:#ffffff; color:#0f172a; font:inherit;
}

/* Hide Leaflet zoom buttons on mobile */
@media (max-width: 960px){
  .leaflet-control-zoom { display: none !important; }
}



  </style>
</head>
<body>
  <header>
    <h1>Time and Place</h1>
      <div class="headerControls">
    <input type="date" id="datePicker" aria-label="Select date">
  </div>
</header>
<div id="headerSpacer" aria-hidden="true"></div>
<!-- keep your pinnedEvent below -->
<!-- <div id="pinnedEvent" class="pinned hidden" aria-live="polite"></div> -->

<link href="https://unpkg.com/maplibre-gl@latest/dist/maplibre-gl.css" rel="stylesheet" />
<script src="https://unpkg.com/maplibre-gl@latest/dist/maplibre-gl.js"></script>
<script src="https://unpkg.com/pmtiles@latest/dist/pmtiles.js"></script>

<div id="map" style="position:fixed; inset:0;"></div>
<script>
  const protocol = new pmtiles.Protocol();
  maplibregl.addProtocol("pmtiles", protocol.tile);

  fetch("./style.json")   // style.json in the repo root (project page)
    .then(r => r.json())
    .then(style => {
      const map = new maplibregl.Map({
        container: "map",
        style,
        center: [-79.3832, 43.6532],
        zoom: 11
      });
      map.addControl(new maplibregl.NavigationControl(), "top-right");
      window.map = map;
    });
</script>




  <!-- Leaflet JS -->
  <!--<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  PapaParse for CSV -->
  <!--<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script> -->

  <script>
     Toronto-only view + monochrome basemap (Carto Positron)
    const TORONTO_BOUNDS = L.latLngBounds([[43.58, -79.65], [43.80, -79.12]]);
    const map = L.map('map', { minZoom: 10, maxZoom: 19, maxBounds: TORONTO_BOUNDS, maxBoundsViscosity: 0.9, zoomControl: true, zoomSnap: 0.5 });
    map.fitBounds(TORONTO_BOUNDS, { padding: [20, 20] });
    map.createPane('labels'); map.getPane('labels').style.zIndex = 650; map.getPane('labels').style.pointerEvents = 'none';
    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png', { subdomains: 'abcd', maxZoom: 20, attribution: '&copy; OpenStreetMap contributors &copy; CARTO' }).addTo(map);
    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png', { subdomains: 'abcd', maxZoom: 20, pane: 'labels' }).addTo(map);



    
function applyZoomCtrlVisibility(){
  const isMobile = window.matchMedia('(max-width: 960px)').matches;
  const hasZoomEl = !!document.querySelector('.leaflet-control-zoom');

  if (isMobile) {
    if (map.zoomControl) map.zoomControl.remove();      // remove if present
  } else {
    if (!hasZoomEl) L.control.zoom({ position: 'topleft' }).addTo(map); // re-add on desktop
  }
}
applyZoomCtrlVisibility();
window.addEventListener('resize', applyZoomCtrlVisibility);




// --- Current location pin (+ accuracy circle), no zoom/snap ---
const userLayer = L.layerGroup().addTo(map);
let userMarker = null;
let userAccuracy = null;
let geoWatchId = null;

// NEW: track first pan + first UI refresh
let userCenteredOnce = false;
let userFirstFixNotified = false;

// 📍 control
const locateControl = L.control({ position: 'topleft' });
locateControl.onAdd = function(map){
  const div = L.DomUtil.create('div', 'leaflet-bar locate-btn');
  const btn = L.DomUtil.create('button', '', div);
  btn.type = 'button';
  btn.title = 'Show my location';
  btn.setAttribute('aria-label', 'Show my location');
  btn.textContent = '📍';
  L.DomEvent.disableClickPropagation(div);
  btn.onclick = () => toggleGeolocation();
  return div;
};
locateControl.addTo(map);

function toggleGeolocation(){
  if (!('geolocation' in navigator)) {
    alert('Geolocation is not supported on this device/browser.');
    return;
  }

  // Turn OFF if already watching
  if (geoWatchId){
    navigator.geolocation.clearWatch(geoWatchId);
    geoWatchId = null;

    if (userMarker)   { userLayer.removeLayer(userMarker);   userMarker = null; }
    if (userAccuracy) { userLayer.removeLayer(userAccuracy); userAccuracy = null; }

    // reset first-time flags
    userCenteredOnce = false;
    userFirstFixNotified = false;

    // refresh UI to hide Directions buttons
    if (typeof render === 'function') render();
    if (typeof renderPinned === 'function') renderPinned();
    return;
  }

  // Turn ON (start watching)
  userCenteredOnce = false;
  userFirstFixNotified = false;

  geoWatchId = navigator.geolocation.watchPosition(onGeoSuccess, onGeoError, {
    enableHighAccuracy: true,
    maximumAge: 10000,
    timeout: 10000
  });
}

function onGeoSuccess(pos){
  const { latitude: lat, longitude: lng, accuracy } = pos.coords;

  if (!userMarker){
    userMarker = L.circleMarker([lat, lng], {
      radius: 7, weight: 2,
      color: '#0ea5e9', fillColor: '#0ea5e9', fillOpacity: 0.6
    }).addTo(userLayer).bindPopup('You are here');
  } else {
    userMarker.setLatLng([lat, lng]);
  }

  if (!userAccuracy){
    userAccuracy = L.circle([lat, lng], {
      radius: accuracy, color: '#0ea5e9', weight: 1, opacity: 0.5, fillOpacity: 0.08
    }).addTo(userLayer);
  } else {
    userAccuracy.setLatLng([lat, lng]);
    userAccuracy.setRadius(accuracy);
  }

  // 🔒 Do NOT change zoom. Only pan once on the first fix, and only if off-screen.
  if (!userCenteredOnce) {
    if (!map.getBounds().contains([lat, lng])) {
      map.panTo([lat, lng], { animate: true, duration: 0.5 }); // no zoom change
    }
    userCenteredOnce = true;
  }

  // Refresh UI once so Directions buttons appear, then stop re-rendering on each GPS tick
  if (!userFirstFixNotified) {
    if (typeof render === 'function') render();
    if (typeof renderPinned === 'function') renderPinned();
    userFirstFixNotified = true;
  }
}

function onGeoError(err){
  console.warn('Geolocation error:', err);
  alert('Could not get your location: ' + (err && err.message ? err.message : 'unknown error'));

  // If there was an error after turning on, refresh UI to hide buttons
  if (typeof render === 'function') render();
  if (typeof renderPinned === 'function') renderPinned();
}

window.addEventListener('resize', () => map.invalidateSize());
    
// ===== Fast auto-hide header =====
const headerEl = document.querySelector('header');
const spacerEl = document.getElementById('headerSpacer');

function setHeaderHeightVar(){
  if (!headerEl || !spacerEl) return;
  const h = headerEl.offsetHeight || 64;
  document.documentElement.style.setProperty('--header-h', h + 'px');
  spacerEl.style.height = h + 'px';
}
window.addEventListener('load', setHeaderHeightVar);
window.addEventListener('resize', setHeaderHeightVar);

// Hide on scroll down, show on scroll up (more sensitive + rAF for smoothness)
let lastY = window.scrollY, ticking = false;
const MIN_DELTA = 4;  // smaller = quicker reaction

window.addEventListener('scroll', () => {
  const y = Math.max(0, window.scrollY);
  const delta = y - lastY;

  if (y <= SHOW_AT_TOP || delta < -MIN_DELTA) {
    // scrolling up (or at top): show header
    document.body.classList.remove('header-hidden');
  } else if (delta > MIN_DELTA && y > HIDE_AFTER) {
    // scrolling down: hide header
    document.body.classList.add('header-hidden');
  }

  lastY = y;
}, { passive: true });


// Darken + add color to base tiles
map.getPane('tilePane').style.filter =
  'grayscale(0%) hue-rotate(348deg) saturate(800%) brightness(0.85) contrast(1.38)';

// Invert labels so they stay light on dark
map.getPane('labels').style.filter = 'brightness(1.0)';

    // One-off events (existing sheet)
    const GOOGLE_SHEET_CSV_URL =
      "https://docs.google.com/spreadsheets/d/e/2PACX-1vT9IWLxL_UnRLjmKdpwkFdVeC9scZfML65HyqbdppY7DC54RPv0Q3bkRa5-scyNON9pVkjwsoTcTWX-/pub?gid=811741087&single=true&output=csv";

    // NEW: weekly/recurring events (publish this sheet to CSV and paste the link)
    const WEEKLY_SHEET_CSV_URL =
      "https://docs.google.com/spreadsheets/d/e/2PACX-1vRKFzStHyi9c8o4WQCIIJfCMsexEDTuMTjkmZn1oZcDT9npyqTyp7f5IT0pyuShm5ADhUIYY86kOqLm/pub?gid=811741087&single=true&output=csv";

    // How far to expand weekly events (today → today+N days)
    const RECUR_WINDOW_DAYS = 90;

    const CATEGORY_COLORS = {
      "Trivia": getCSS('--cat-active'),
      "Live Music": getCSS('--cat-creative'),
      "Open Mic": getCSS('--cat-entertain'),
      "Karaoke": getCSS('--cat-competitive'),
      "Relaxing & Romantic": getCSS('--cat-relax')
    };

    function categoryColor(cat){
  return CATEGORY_COLORS[cat] || '#64748b'; // fallback for unknown categories
}

    function getCSS(varName){ return getComputedStyle(document.documentElement).getPropertyValue(varName).trim(); }

    //const markersLayer = L.layerGroup().addTo(map);
    const datePicker = document.getElementById('datePicker');
    const catChips  = document.getElementById('catChips');
    const listEl    = document.getElementById('eventsList');
    const countEl   = document.getElementById('count');
    

    const pinnedEl  = document.getElementById('pinnedEvent');
let pinnedEvent = null;

function isMobile(){ return window.matchMedia('(max-width: 960px)').matches; }

function setPinned(ev){
  pinnedEvent = ev;
  renderPinned();
}

function renderPinned(){
  if(!pinnedEl) return;

  if(pinnedEvent && isMobile()){
    const color = CATEGORY_COLORS[pinnedEvent.category] || '#888';

    // Build a Google Maps directions URL if user location is active
    let dirUrl = '';
    try {
      if (typeof userMarker !== 'undefined' && userMarker && userMarker.getLatLng){
        const u = userMarker.getLatLng();
        if (Number.isFinite(pinnedEvent.lat) && Number.isFinite(pinnedEvent.lng)) {
          // Use lat/lng if available
          dirUrl = `https://www.google.com/maps/dir/?api=1&origin=${encodeURIComponent(`${u.lat},${u.lng}`)}&destination=${encodeURIComponent(`${pinnedEvent.lat},${pinnedEvent.lng}`)}&travelmode=driving`;
        } else {
          // Fallback to address/venue/name
          const destText = pinnedEvent.address || pinnedEvent.venue || pinnedEvent.name || '';
          if (destText){
            dirUrl = `https://www.google.com/maps/dir/?api=1&origin=${encodeURIComponent(`${u.lat},${u.lng}`)}&destination=${encodeURIComponent(destText)}&travelmode=driving`;
          }
        }
      }
    } catch(_) {}

    const directionsBtn = dirUrl ? `<a class="dirBtn" href="${dirUrl}" target="_blank" rel="noopener">Directions</a>` : '';

    pinnedEl.classList.remove('hidden');
    pinnedEl.innerHTML = `
      <div class="pinnedCard">
        <button id="pinnedClear" class="pinnedClear" aria-label="Clear pinned event" title="Clear">×</button>
        <img class="thumb" src="${pinnedEvent.photo || 'https://placehold.co/200x200?text=Photo'}" alt="${safe(pinnedEvent.name||'event')}">
        <div>
          <div class="pinnedTitle">${safe(pinnedEvent.name)}</div>
          <div class="pinnedMeta">${safe(pinnedEvent.venue || pinnedEvent.address || '')}</div>
          <div class="pinnedMeta">${safe(pinnedEvent.date)} ${pinnedEvent.time?`• ${safe(pinnedEvent.time)}`:''}</div>
          <div class="pinnedMeta"><a href="${pinnedEvent.link}" target="_blank" rel="noopener">Event page</a></div>
          <div style="margin-top:6px">
            <span class="pinnedBadge"><span class="dot" style="background:${color}"></span>${safe(pinnedEvent.category||'')}</span>
          </div>
          ${directionsBtn ? `<div class="pinnedActions">${directionsBtn}</div>` : ``}
        </div>
      </div>
    `;

    // Wire the clear (×) button
    const btn = document.getElementById('pinnedClear');
    if (btn) btn.addEventListener('click', clearPinned);

  } else {
    pinnedEl.classList.add('hidden');
    pinnedEl.innerHTML = '';
  }
}



function clearPinned(){
  pinnedEvent = null;
  renderPinned();
}

window.addEventListener('resize', renderPinned); // keep it correct on rotate/resize




    // ----- Date helpers -----
    function isoLocal(d){ const off=d.getTimezoneOffset()*60000; return new Date(d.getTime()-off).toISOString().slice(0,10); }
    
    function startOfDay(d){ const x=new Date(d); x.setHours(0,0,0,0); return x; }
function monthKey(d){ return d.getFullYear()*12 + d.getMonth(); } // for incrementing months

function weekdayOrdinalInMonth(d){
  // e.g., d = 2025-10-14 (Tue) → returns 2 (2nd Tuesday)
  const day = d.getDate();
  return Math.floor((day - 1) / 7) + 1; // 1..5
}

function nthWeekdayOfMonth(year, monthIndex, weekday, nth){
  // weekday: 0=Sun … 6=Sat, nth: 1..5 (5 may not exist every month)
  const firstOfMonth = new Date(year, monthIndex, 1);
  const delta = (weekday - firstOfMonth.getDay() + 7) % 7;
  const firstTarget = 1 + delta;      // date of first desired weekday
  const date = firstTarget + (nth - 1) * 7;
  const result = new Date(year, monthIndex, date);
  if (result.getMonth() !== monthIndex) return null; // overflow → no such nth this month
  return result;
}
    
    function normalizeDate(str){
      if(!str) return '';
      const s=String(str).trim();
      const hy=s.split('-');
      if(hy.length===3 && hy[0].length===4){ const y=+hy[0], m=+hy[1], d=+hy[2]; if(m>=1&&m<=12&&d>=1&&d<=31){ return `${y}-${String(m).padStart(2,'0')}-${String(d).padStart(2,'0')}`; } }
      const sl=s.split('/');
      if(sl.length===3){ let a=+sl[0], b=+sl[1], y=+sl[2]; let m,d; if(a>12){ d=a; m=b; } else { m=a; d=b; } if(m>=1&&m<=12&&d>=1&&d<=31){ return `${y}-${String(m).padStart(2,'0')}-${String(d).padStart(2,'0')}`; } }
      const dt=new Date(s); if(!isNaN(dt)) return isoLocal(dt);
      return s;
    }
    function addDays(d, n){ const nd=new Date(d); nd.setDate(nd.getDate()+n); return nd; }
    function clampDateRange(start, end){
      // Optional: clamp by Start/End in weekly rows
      return {start: new Date(start), end: new Date(end)};
    }
    function parseCoordsToLatLng(val){
  const s = String(val || '').trim();
  // find first two numbers that look like coordinates, in order
  const m = s.match(/(-?\d+(?:\.\d+)?)[^\d-]+(-?\d+(?:\.\d+)?)/);
  if (!m) return { lat: null, lng: null };
  return { lat: parseFloat(m[1]), lng: parseFloat(m[2]) };
}

    // Parse weekday strings/numbers to 0–6 (Sun=0)
    const DOW_MAP = { sun:0, sunday:0, mon:1, monday:1, tue:2, tues:2, tuesday:2,
      wed:3, weds:3, wednesday:3, thu:4, thur:4, thurs:4, thursday:4, fri:5, friday:5, sat:6, saturday:6 };
    function parseDOW(val){
      if(val==null) return null;
      const s=String(val).trim().toLowerCase();
      if(s==='' ) return null;
      if(/^\d$/.test(s)){ const n=+s; return (n>=0 && n<=6) ? n : null; }
      return (s in DOW_MAP) ? DOW_MAP[s] : null;
    }

    let allEvents = [];
    let activeCats = new Set(Object.keys(CATEGORY_COLORS));

function buildCategoryChips(){
  // Build chips from whatever categories actually exist in the merged data
  const catsFromData = Array.from(new Set(
    allEvents.map(e => (e.category || 'Other').trim())
  )).sort();

  // Start with all categories ON
  activeCats = new Set(catsFromData);

  catChips.innerHTML = '';
  catsFromData.forEach(cat => {
    const color = categoryColor(cat);
    const chip = document.createElement('div');
    chip.className = 'chip';
    chip.setAttribute('data-cat', cat);
    chip.innerHTML = `<span class="dot" style="background:${color}"></span>${cat}`;
    chip.onclick = () => {
      if (activeCats.has(cat)) activeCats.delete(cat); else activeCats.add(cat);
      chip.style.opacity = activeCats.has(cat) ? 1 : 0.4;
      render();
    };
    catChips.appendChild(chip);
  });
}

    // Promise wrapper for Papa.parse (CSV -> rows)
    function loadCSV(url){
      return new Promise((resolve, reject) => {
        if(!url) return resolve([]);
        Papa.parse(url, {
          download: true, header: true, skipEmptyLines: true,
          complete: (res) => resolve(res.data || []),
          error: reject
        });
      });
    }

    // Cleaners for both sheets
   function cleanOneOff(r){
  const coordsField = r["Coords"] || r["Coordinates"] || r["Lat/Lng"] || r["Location"] || '';

  let lat = parseFloat(r["Lat"]);
  let lng = parseFloat(r["Lng"]);

  if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
    const c = parseCoordsToLatLng(coordsField);
    if (Number.isFinite(c.lat) && Number.isFinite(c.lng)) {
      lat = c.lat; lng = c.lng;
    } else {
      lat = null; lng = null;
    }
  }

  return {
    name: (r["Event name"] || r.name || '').trim(),
    venue: (r["Venue"] || r.venue || '').trim(),
    date: normalizeDate((r["Date"] || r.date || '').trim()),
    time: (r["Time"] || r.time || '').trim(),
    category: (r["Category"] || r.category || '').trim(),
    link: (r["Link"] || r.link || '').trim(),
    address: (r["Address"] || r.address || '').trim(),
    photo: (r["Photo"] || r.photo || '').trim(),
    lat, lng,
    __source: 'oneoff'
  };
}

function cleanWeekly(r){
  const dowRaw = r["Day"] ?? r["Weekday"] ?? r["weekday"] ?? r["day"];
  const startRaw = normalizeDate((r["Start"] || r["start"] || '').trim());
  const endRaw   = normalizeDate((r["End"]   || r["end"]   || '').trim());
  const excludes = String(r["Exclude Dates"] || r["Exclude"] || '')
                    .split(',').map(s=>normalizeDate(s.trim())).filter(Boolean);

  // Coords parsing fallback
  const coordsField = r["Coords"] || r["Coordinates"] || r["Lat/Lng"] || r["Location"] || '';
  let lat = parseFloat(r["Lat"]); let lng = parseFloat(r["Lng"]);
  if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
    const c = parseCoordsToLatLng(coordsField);
    lat = Number.isFinite(c.lat) ? c.lat : null;
    lng = Number.isFinite(c.lng) ? c.lng : null;
  }

  // ---- Repeat parsing (very tolerant) ----
  const raw = (r["Repeat"] ?? r["Frequency"] ?? "").toString().toLowerCase().trim();
  const norm = raw.replace(/[\s-_/]/g, ''); // remove spaces, hyphens, slashes, underscores
  let repeat = 'weekly';
  if (['biweekly','2w','fortnightly','everyotherweek','q2w'].includes(norm)) repeat = 'biweekly';
  else if (['monthly','1m','monthlynth','nthmonthly'].includes(norm)) repeat = 'monthly';

  return {
    name: (r["Event name"] || r.name || '').trim(),
    venue: (r["Venue"] || r.venue || '').trim(),
    day: parseDOW(dowRaw),                 // 0=Sun … 6=Sat
    time: (r["Time"] || r.time || '').trim(),
    category: (r["Category"] || r.category || '').trim(),
    link: (r["Link"] || r.link || '').trim(),
    address: (r["Address"] || r.address || '').trim(),
    photo: (r["Photo"] || r.photo || '').trim(),
    lat, lng,
    start: startRaw,
    end: endRaw,
    excludes,
    repeat,                                // now normalized to 'weekly' | 'biweekly' | 'monthly'
    __source: 'weekly'
  };
}


    // Expand weekly rows into dated event instances within [rangeStart, rangeEnd]
function startOfDay(d){ const x=new Date(d); x.setHours(0,0,0,0); return x; }
function addDays(d, n){ const nd=new Date(d); nd.setDate(nd.getDate()+n); return nd; }
function isoLocal(d){ const off=d.getTimezoneOffset()*60000; return new Date(d.getTime()-off).toISOString().slice(0,10); }
function weekdayOrdinalInMonth(d){ return Math.floor((d.getDate()-1)/7)+1; }
function nthWeekdayOfMonth(year, monthIndex, weekday, nth){
  const first = new Date(year, monthIndex, 1);
  const delta = (weekday - first.getDay() + 7) % 7;
  const date = 1 + delta + (nth-1)*7;
  const res = new Date(year, monthIndex, date);
  return res.getMonth() === monthIndex ? res : null;
}

function expandWeekly(row, rangeStart, rangeEnd){
  const out = [];
  if (row.day == null) return out;

  const hardStart = row.start ? startOfDay(new Date(row.start)) : null;
  const hardEnd   = row.end   ? startOfDay(new Date(row.end))   : null;

  let effStart = startOfDay(rangeStart);
  let effEnd   = startOfDay(rangeEnd);
  if (hardStart && hardStart > effStart) effStart = hardStart;
  if (hardEnd && hardEnd < effEnd)       effEnd   = hardEnd;

  const excludes = new Set((row.excludes || []).filter(Boolean));

  // ----- WEEKLY / BIWEEKLY -----
  if (row.repeat === 'weekly' || row.repeat === 'biweekly'){
    const anchorBase = hardStart || effStart;
    const first = new Date(anchorBase);
    const delta = (row.day - first.getDay() + 7) % 7;
    first.setDate(first.getDate() + delta);

    const step = (row.repeat === 'biweekly') ? 14 : 7;

    // If the first anchor is still before effStart, advance by whole steps to preserve phase
    let d = new Date(first);
    while (d < effStart) d = addDays(d, step);

    for (; d <= effEnd; d = addDays(d, step)){
      const iso = isoLocal(d);
      if (!excludes.has(iso)){
        out.push({
          name: row.name, venue: row.venue, date: iso, time: row.time,
          category: row.category, link: row.link, address: row.address,
          photo: row.photo, lat: row.lat, lng: row.lng, __source: 'weekly'
        });
      }
    }
    return out;
  }

  // ----- MONTHLY (nth weekday anchored by Start/first match) -----
  if (row.repeat === 'monthly'){
    const base = hardStart || effStart;
    const first = new Date(base);
    const delta = (row.day - first.getDay() + 7) % 7;
    first.setDate(first.getDate() + delta);
    const nth = weekdayOrdinalInMonth(first);

    let y = first.getFullYear(), m = first.getMonth();
    // advance to first >= effStart
    while (true){
      const c = nthWeekdayOfMonth(y, m, row.day, nth);
      if (c && c >= effStart) break;
      m++; if (m>11){ m=0; y++; }
      if (new Date(y, m, 1) > effEnd) return out;
    }
    // collect until effEnd
    while (true){
      const d = nthWeekdayOfMonth(y, m, row.day, nth);
      if (!d) { m++; if (m>11){ m=0; y++; } if (new Date(y, m, 1) > effEnd) break; continue; }
      if (d > effEnd) break;
      const iso = isoLocal(d);
      if (!excludes.has(iso)){
        out.push({
          name: row.name, venue: row.venue, date: iso, time: row.time,
          category: row.category, link: row.link, address: row.address,
          photo: row.photo, lat: row.lat, lng: row.lng, __source: 'weekly'
        });
      }
      m++; if (m>11){ m=0; y++; }
    }
    return out;
  }

  // Fallback
  return expandWeekly({...row, repeat:'weekly'}, rangeStart, rangeEnd);
}




    // Load both sheets, expand weekly, merge, then render
    async function loadAll(){
  try{
    const [oneOffRaw, weeklyRaw] = await Promise.all([
      loadCSV(GOOGLE_SHEET_CSV_URL),
      loadCSV(WEEKLY_SHEET_CSV_URL)
    ]);

    const oneOff = (oneOffRaw || []).map(cleanOneOff).filter(r => r.name && r.date);
    const weekly = (weeklyRaw || []).map(cleanWeekly).filter(r => r.name && r.day != null);

    // Determine expansion window (today → today+RECUR_WINDOW_DAYS)
    const today = new Date();
    const rangeStart = new Date(today.getFullYear(), today.getMonth(), today.getDate()); // midnight local
    const rangeEnd   = addDays(rangeStart, RECUR_WINDOW_DAYS);

    const weeklyExpanded = weekly.flatMap(r => expandWeekly(r, rangeStart, rangeEnd));

    // Merge and normalize dates
    allEvents = [...oneOff, ...weeklyExpanded]
      .map(e => ({ ...e, date: normalizeDate(e.date) }))
      .filter(e => e.date);

    buildCategoryChips();

// Build calendar bounds from merged dates and pick a safe default date
const dates = Array.from(new Set(allEvents.map(r => r.date))).sort();
const todayStr = isoLocal(new Date());

if (datePicker) {
  if (dates.length) {
    datePicker.min   = dates[0];
    datePicker.max   = dates[dates.length - 1];
    datePicker.value = dates.includes(todayStr) ? todayStr : dates[0];
  } else {
    datePicker.min = todayStr;
    datePicker.max = todayStr;
    datePicker.value = todayStr;
  }
} // if there’s no datePicker for some reason, we just show all dates

render();

    render();
  } catch(err){
    console.error('CSV load error', err);
    alert('Could not load one or both CSVs. Please make sure both sheets are published to the web as CSV.');
  }
}



    // userMarker must be the one you create in your geolocation code
function hasUserLocation(){
  return typeof userMarker !== 'undefined' && userMarker && userMarker.getLatLng;
}

function gmapsDirectionsURL(oLat, oLng, dLat, dLng, mode='driving'){
  const origin = `${oLat},${oLng}`;
  const dest   = `${dLat},${dLng}`;
  return `https://www.google.com/maps/dir/?api=1&origin=${encodeURIComponent(origin)}&destination=${encodeURIComponent(dest)}&travelmode=${encodeURIComponent(mode)}`;
}

// Fallback if an event is missing lat/lng: use address/venue/name
function gmapsDirectionsURLFallback(oLat, oLng, ev){
  if (Number.isFinite(ev.lat) && Number.isFinite(ev.lng)){
    return gmapsDirectionsURL(oLat, oLng, ev.lat, ev.lng);
  }
  const destText = ev.address || ev.venue || ev.name || '';
  if (!destText) return '';
  const origin = `${oLat},${oLng}`;
  return `https://www.google.com/maps/dir/?api=1&origin=${encodeURIComponent(origin)}&destination=${encodeURIComponent(destText)}`;
}

let selectedEventKey = null; // tracks the currently-selected list item


  function render(){
  // Read date from the picker (or leave blank = show all dates)
  const chosenDate = (datePicker && datePicker.value) ? datePicker.value : '';

  const filtered = allEvents.filter(e => {
    const matchDate = chosenDate ? e.date === chosenDate : true;
    const matchCat  = activeCats.has((e.category || 'Other').trim());
    return matchDate && matchCat; // (search removed)
  });

      markersLayer.clearLayers();
      const pts = [];
      filtered.forEach((e,i) => {
        if(Number.isFinite(e.lat) && Number.isFinite(e.lng)){
          const color = CATEGORY_COLORS[e.category] || '#888';
          //const marker = L.circleMarker([e.lat, e.lng], {
            radius: 8, weight:2, color: color, fillColor: color, fillOpacity:0.2
          }).addTo(markersLayer);
          marker.bindPopup(
            `<strong>${safe(e.name)}</strong><br>${safe(e.venue||'')}${e.time?` • ${safe(e.time)}`:''}<br>${safe(e.date)}<br><a href="${e.link}" target="_blank" rel="noopener">Event page</a>`
          );
          marker.on('click', () => {
  if (isMobile()) {
    setPinned(e);        // show pinned card on phones
  } else {
    highlightCard(i);    // keep existing behavior on desktop
  }
});

          pts.push([e.lat,e.lng]);
        }
      });
      if(pts.length){ map.fitBounds(pts, {padding:[30,30]}); }

      listEl.innerHTML='';
      filtered.forEach((e,i) => {
        const row = document.createElement('div');
        row.className='item';
        // stable key for this event (works across filters)
const key = `${e.name || ''}|${e.date || ''}|${e.venue || ''}|${e.address || ''}`;
row.dataset.key = key;
if (selectedEventKey === key) row.classList.add('selected');

row.onclick = (ev) => {
  // If the click was on (or inside) the Directions button, do nothing here
  if (ev.target.closest('.dirBtn')) return;

  const myKey = row.dataset.key;
  const onMobile = (typeof isMobile === 'function')
    ? isMobile()
    : window.matchMedia('(max-width: 960px)').matches;

  if (onMobile) {
    // Mobile: second tap on the SAME item opens the link
    if (selectedEventKey === myKey) {
      if (e.link) window.open(e.link, '_blank', 'noopener');
      return;
    }
  } else {
    // Desktop: single-click never opens the link
    if (selectedEventKey === myKey) return;
  }

  // Select + behaviors
  selectedEventKey = myKey;
  document.querySelectorAll('.item.selected').forEach(el => el.classList.remove('selected'));
  row.classList.add('selected');

  if (Number.isFinite(e.lat) && Number.isFinite(e.lng)) {
    map.flyTo([e.lat, e.lng], 15, { duration: 0.6 });
  }
  if (onMobile && typeof setPinned === 'function') setPinned(e);
};

row.ondblclick = (ev) => {
  // Ignore double-clicks on the Directions button
  if (ev.target.closest('.dirBtn')) return;

  const onMobile = (typeof isMobile === 'function')
    ? isMobile()
    : window.matchMedia('(max-width: 960px)').matches;
  if (onMobile) return;

  ev.preventDefault();
  if (e.link) window.open(e.link, '_blank', 'noopener');
};




        
        // --- build one list row ---
const color = CATEGORY_COLORS[e.category] || '#888';

const stripe = document.createElement('div');
stripe.className = 'leftStripe';
stripe.style.background = color;
stripe.style.gridRow = '1 / span 2';
stripe.style.alignSelf = 'stretch';

const img = document.createElement('img');
img.className = 'thumb';
img.src = e.photo || 'https://placehold.co/200x200?text=Photo';
img.alt = e.name || 'event photo';

const meta = document.createElement('div');
meta.className = 'meta';

// Build a Google Maps directions link if user location is available
let dirUrl = '';
if (hasUserLocation()){
  const u = userMarker.getLatLng();
  dirUrl = gmapsDirectionsURLFallback(u.lat, u.lng, e);
}
const dirLink = dirUrl
  ? `<div class="sub"><a class="dirBtn" href="${dirUrl}" target="_blank" rel="noopener">Directions</a></div>`
  : '';







// Mobile: title + badge on one line; Desktop: original layout
if (typeof isMobile === 'function' ? isMobile() : window.matchMedia('(max-width: 960px)').matches) {
  meta.innerHTML = `
  <div class="titleRow">
    <div class="title">${safe(e.name)}</div>
    <span class="badge"><span class="dot" style="background:${color}"></span>${safe(e.category||'')}</span>
  </div>
  <div class="sub">${safe(e.venue || e.address || '')}</div>
  ${e.time ? `<div class="sub">${safe(e.time)}</div>` : ``}
  ${dirLink || ``}
`;

} else {
  // DESKTOP (no "Event page" link here)
meta.innerHTML = `
  <div class="title">${safe(e.name)}</div>
  <div class="sub">${safe(e.venue || e.address || '')}</div>
  ${e.time ? `<div class="sub">${safe(e.time)}</div>` : ``}
  <div><span class="badge"><span class="dot" style="background:${color}"></span>${safe(e.category||'')}</span></div>
  ${dirLink || ``}



  
`;}

// Prevent row handlers from firing when clicking Directions
const dirBtnEl = meta.querySelector('.dirBtn');
if (dirBtnEl) {
  dirBtnEl.addEventListener('click', (ev) => {
    ev.stopPropagation();     // don't bubble to the row
    // open explicitly so we can also preventDefault (avoids odd behaviors)
    ev.preventDefault();
    window.open(dirBtnEl.href, '_blank', 'noopener');
  });
  // Also suppress dblclick bubbling from the button
  dirBtnEl.addEventListener('dblclick', (ev) => {
    ev.stopPropagation();
    ev.preventDefault();
  });
}




// Order content: on phones -> text left, image right; desktop -> image left, text right
const thumbWrap = document.createElement('div');
thumbWrap.appendChild(img);

const rowWrap = document.createElement('div');
rowWrap.style.display = 'contents';

// Text/links left, image right (mobile AND desktop)
rowWrap.appendChild(meta);
rowWrap.appendChild(thumbWrap);


row.appendChild(stripe);
row.appendChild(rowWrap);
listEl.appendChild(row);

      });
      countEl.textContent = `${filtered.length} event${filtered.length===1?'':'s'} shown`;
    }

    function highlightCard(index){
  const cards = [...document.querySelectorAll('.item')];
  const el = cards[index];
  if(!el) return;

  // Smoothly scroll inside the list container only
  const parent = listEl; // #eventsList
  const target = el.offsetTop - (parent.clientHeight / 2) + (el.clientHeight / 2);
  parent.scrollTo({ top: Math.max(0, target), behavior: 'smooth' });

  // Pulse highlight so it stands out
  el.animate([{ background: '#0b1320' }, { background: 'transparent' }], { duration: 900 });
}

    function safe(s){ return (s||'').toString().replace(/[&<>]/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;"}[c])); }

if (datePicker) {
  datePicker.addEventListener('change', () => {
    selectedDate = datePicker.value || '';           // keep fallback in sync
    if (typeof setHeaderHeightVar === 'function') setHeaderHeightVar();
    render();
  });
}

    //searchEl.addEventListener('input', () => { window.clearTimeout(window.__t); window.__t=setTimeout(render,200); });

    loadAll();

    
  </script>
</body>
</html>
